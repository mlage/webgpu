(()=>{"use strict";var e;const n=(e="triangle-list")=>{return n=void 0,t=void 0,r=function*(){var n;const t=navigator.gpu?"webGPU suportado":"webGPU não suportado";if("webGPU não suportado"===t)throw console.log(t),"Seu navegador atual não suporta webGPU!";const o=document.querySelector("#canvas-webgpu"),r=window.devicePixelRatio||1;o.width=1024*r,o.height=768*r;const c=yield null===(n=navigator.gpu)||void 0===n?void 0:n.requestAdapter(),i=yield null==c?void 0:c.requestDevice(),a=o.getContext("webgpu"),u="bgra8unorm";let v;a.configure({device:i,format:u,alphaMode:"premultiplied"}),"triangle-strip"===e&&(v="uint32");const l="\n        const pos: array<vec2<f32>, 9>=  array<vec2<f32>, 9>(\n            vec2<f32>(0.0, 0.7),\n            vec2<f32>(-0.3, 0.2),\n            vec2<f32>(0.3, 0.2),\n            vec2<f32>(-0.3, 0.0),\n            vec2<f32>(0.3, 0.0),\n            vec2<f32>(-0.3, -0.4),\n            vec2<f32>(0.4, -0.2),\n            vec2<f32>(0.0, -0.7),\n            vec2<f32>(0.4, -0.7),\n        );\n\n        const color: array<vec3<f32>, 9>=  array<vec3<f32>, 9>(\n            vec3<f32>(1.0, 0.0, 0.0),\n            vec3<f32>(0.0, 1.0, 0.0),\n            vec3<f32>(0.0, 0.0, 1.0),\n            vec3<f32>(1.0, 0.0, 0.0),\n            vec3<f32>(0.0, 1.0, 0.0),\n            vec3<f32>(0.0, 0.0, 1.0),\n            vec3<f32>(1.0, 0.0, 0.0),\n            vec3<f32>(0.0, 1.0, 0.0),\n            vec3<f32>(0.0, 0.0, 1.0)\n        );\n        \n        struct Output{\n            @builtin(position) Position: vec4<f32>,\n            @location(0) vColor: vec4<f32>,\n        }\n\n        @vertex\n        fn main(@builtin(vertex_index) VertexIndex: u32) -> Output {\n            var out: Output;\n            out.Position=vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n            out.vColor=vec4<f32>(color[VertexIndex], 1.0);\n            return out;\n        }\n    ",d="  \n        @fragment\n        fn main(@location(0) vColor: vec4<f32>) -> @location(0) vec4<f32> {\n            return vColor;\n        }\n    ",f=i.createRenderPipeline({vertex:{module:i.createShaderModule({code:l}),entryPoint:"main"},fragment:{module:i.createShaderModule({code:d}),entryPoint:"main",targets:[{format:u}]},primitive:{topology:e,stripIndexFormat:v},layout:"auto"}),s=i.createCommandEncoder(),p=a.getCurrentTexture().createView(),g=s.beginRenderPass({colorAttachments:[{clearValue:[0,0,0,1],storeOp:"store",loadOp:"clear",view:p}]});g.setPipeline(f),g.draw(9),g.end(),i.queue.submit([s.finish()])},new((o=void 0)||(o=Promise))((function(e,c){function i(e){try{u(r.next(e))}catch(e){c(e)}}function a(e){try{u(r.throw(e))}catch(e){c(e)}}function u(n){var t;n.done?e(n.value):(t=n.value,t instanceof o?t:new o((function(e){e(t)}))).then(i,a)}u((r=r.apply(n,t||[])).next())}));var n,t,o,r};null===(e=document.querySelector("#primitives"))||void 0===e||e.addEventListener("change",(e=>{const t=e.target,o=t.options[t.selectedIndex].value;n(o)})),n()})();
//# sourceMappingURL=main.bundle.js.map