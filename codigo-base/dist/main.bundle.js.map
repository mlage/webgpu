{"version":3,"file":"main.bundle.js","mappings":"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","sources":["webpack://webgpu/./node_modules/gl-matrix/esm/common.js","webpack://webgpu/./node_modules/gl-matrix/esm/mat4.js","webpack://webgpu/./node_modules/gl-matrix/esm/vec3.js","webpack://webgpu/./src/camera.ts","webpack://webgpu/./src/webgpu/pipeline.ts","webpack://webgpu/./src/webgpu/mesh.ts","webpack://webgpu/./src/webgpu/indexed_mesh.ts","webpack://webgpu/./src/webgpu/program.ts","webpack://webgpu/./src/webgpu/gpu_params.ts","webpack://webgpu/./src/main.ts","webpack://webgpu/./src/vertex_data.ts","webpack://webgpu/./src/shader.ts"],"sourcesContent":["/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};","import * as glMatrix from \"./common.js\";\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\n\nexport function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\n\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\n\nexport function translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\n\nexport function fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nexport function getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveNO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\n\nexport var perspective = perspectiveNO;\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveZO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoNO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\n\nexport var ortho = orthoNO;\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoZO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = near * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();","import { mat4, vec3 } from \"gl-matrix\";\r\n\r\nexport default class Camera{\r\n    private viewMatrix: mat4 = mat4.create();\r\n    private projMatrix: mat4 = mat4.create();\r\n    private viewProjMatrix: mat4 = mat4.create();\r\n\r\n    camPosition: vec3 = [0,0,1];\r\n    lookDirection: vec3 = [0,0,0];\r\n    upDirection: vec3 = [0,1,0];\r\n\r\n    left:number = -4.0;\r\n    right:number = 4.0;\r\n    bottom:number = -4.0;\r\n    top:number = 4.0;\r\n    near:number = 0.1;\r\n    far:number = 8.0;\r\n\r\n    fovy:number = Math.PI/2;\r\n    aspect:number;\r\n\r\n    constructor(canvas: HTMLCanvasElement){\r\n        this.aspect = canvas!.width / canvas!.height\r\n    }\r\n\r\n    private typeOfProjection:string = \"perspective\";\r\n\r\n    public set projectionType(type:string){\r\n        if(type !== \"orthogonal\" && type !== \"perspective\") \r\n            throw new Error(\"Invalid type of projection.\");\r\n\r\n        this.typeOfProjection = type;\r\n    }\r\n\r\n    private updateViewMatrix(){\r\n        mat4.identity(this.viewMatrix);\r\n        mat4.lookAt(this.viewMatrix, this.camPosition, this.lookDirection, this.upDirection);\r\n    }\r\n\r\n    private updateProjMatrix(){\r\n        mat4.identity(this.projMatrix);\r\n        if(this.typeOfProjection == \"perspective\")\r\n            mat4.perspective(this.projMatrix, this.fovy, this.aspect, this.near, this.far);\r\n        else\r\n            mat4.ortho(this.projMatrix, this.left * 1024/768, this.right * 1024/768, this.bottom, this.top, this.near, this.far);\r\n    }\r\n\r\n    getViewProjection(){\r\n        this.updateViewMatrix();\r\n        this.updateProjMatrix();\r\n        mat4.identity(this.viewProjMatrix);\r\n        mat4.multiply(this.viewProjMatrix, this.projMatrix, this.viewMatrix);\r\n\r\n        return this.viewProjMatrix;\r\n    }\r\n}","export default class Pipeline{\r\n    private pipelineDescriptor: GPURenderPipelineDescriptor;\r\n\r\n    private buffers: Array<GPUVertexBufferLayout> = [];\r\n\r\n    private device: GPUDevice;\r\n\r\n    private render_pipeline?: GPURenderPipeline;\r\n    private changed: boolean = true;\r\n\r\n    private _depth: boolean = false;\r\n\r\n    get depth(){\r\n        return this._depth;\r\n    }\r\n\r\n    constructor(device: GPUDevice, vertShader: string, fragShader: string, primitive:string){\r\n        let indexFormat=undefined;\r\n        if(primitive===\"line-strip\" || primitive === \"triangle-strip\") indexFormat=\"uint32\";\r\n\r\n        this.pipelineDescriptor = {\r\n            vertex:{\r\n                module:device.createShaderModule({\r\n                    code:vertShader\r\n                }),\r\n                entryPoint:\"main\",\r\n                buffers: this.buffers\r\n            },\r\n            fragment:{\r\n                module:device.createShaderModule({\r\n                    code:fragShader\r\n                }),\r\n                entryPoint:\"main\",\r\n                targets:[{\r\n                    format:'bgra8unorm'\r\n                }]\r\n            },\r\n            primitive:{\r\n                topology:primitive as GPUPrimitiveTopology,\r\n                stripIndexFormat: indexFormat as GPUIndexFormat\r\n            },\r\n            layout:'auto'\r\n        };\r\n            \r\n        this.device = device;\r\n    }\r\n\r\n    enableDepthTest(){\r\n        const depthStencil = {\r\n            format:\"depth24plus\",\r\n            depthWriteEnabled:true,\r\n            depthCompare:\"less\"\r\n        } as GPUDepthStencilState;\r\n\r\n\r\n        this.pipelineDescriptor.depthStencil = depthStencil\r\n        this._depth = true;\r\n\r\n        this.changed = true;\r\n    }\r\n\r\n    setLayout(layout: GPUPipelineLayout){\r\n        this.changed = true;\r\n        this.pipelineDescriptor.layout = layout;\r\n    }\r\n\r\n    public addVertexBuffer(...atributes: Atribute[]){\r\n        this.changed = true;\r\n        const buffer = {} as GPUVertexBufferLayout;\r\n        const atribs: GPUVertexAttribute[] = [];\r\n\r\n        let stride = 0;\r\n\r\n        for(const atribute of atributes){\r\n            atribs.push({\r\n                shaderLocation: atribute.location,\r\n                format: atribute.format || \"float32x3\",\r\n                offset: stride\r\n            })\r\n\r\n            stride+=this.stride(atribute.format || \"float32x3\");\r\n        }\r\n        \r\n        buffer.arrayStride = stride;\r\n        buffer.attributes = atribs;\r\n\r\n        this.buffers.push(buffer);\r\n    }\r\n\r\n    private stride(format: GPUVertexFormat){\r\n        if(format.includes(\"x\")) return Number(format.slice(-4, -2))*Number(format[format.length-1]) / 8;\r\n        \r\n        return Number(format.slice(-2)) / 8;\r\n    }\r\n\r\n    public get renderPipeline(){\r\n        if(this.changed){\r\n            this.render_pipeline = this.device.createRenderPipeline(this.pipelineDescriptor);\r\n            this.changed = false;\r\n        }\r\n\r\n        return this.render_pipeline;\r\n    }\r\n\r\n    static createGPUBuffer = (device: GPUDevice, data: Float32Array, \r\n        usageFlag:GPUBufferUsageFlags=GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST)=>{\r\n            const buffer=device.createBuffer({\r\n                size:data.byteLength,\r\n                usage:usageFlag,\r\n                mappedAtCreation:true\r\n            });\r\n            new Float32Array(buffer.getMappedRange()).set(data);\r\n            buffer.unmap();\r\n            return buffer;\r\n    }\r\n    \r\n    static createGPUBufferUint=(device: GPUDevice, data: Uint32Array, \r\n        usageFlag:GPUBufferUsageFlags=GPUBufferUsage.INDEX| GPUBufferUsage.COPY_DST)=>{\r\n            const buffer=device.createBuffer({\r\n                size:data.byteLength,\r\n                usage:usageFlag,\r\n                mappedAtCreation:true\r\n            });\r\n            new Uint32Array(buffer.getMappedRange()).set(data);\r\n            buffer.unmap();\r\n            return buffer;\r\n    }\r\n\r\n}\r\n\r\nclass Atribute{\r\n    location: number;\r\n    format?: GPUVertexFormat;\r\n    \r\n    constructor(location: number){\r\n        this.location = location;\r\n    }\r\n}\r\n","import { mat4, vec3 } from \"gl-matrix\"\r\nimport Pipeline from \"./pipeline\";\r\n \r\nexport default class Mesh{\r\n    protected device: GPUDevice;\r\n\r\n    protected arrays: Float32Array[] = [];\r\n    protected buffers: GPUBuffer[] = [];\r\n\r\n    pos: vec3 = vec3.fromValues(0,0,0);\r\n    scale: vec3 = vec3.fromValues(1,1,1);\r\n    rotationAngles: vec3 = vec3.fromValues(0,0,0);\r\n    private model_matrix: mat4;\r\n\r\n    protected stride: number;\r\n\r\n    public get modelMatrix(){\r\n        this.createTransforms();\r\n        return this.model_matrix;\r\n    }\r\n\r\n    public get numberOfVertex(){\r\n        return this.arrays[0].length/this.stride;\r\n    }\r\n\r\n    constructor(device: GPUDevice, stride: number = 3){\r\n        this.model_matrix = mat4.create();\r\n\r\n        this.stride = stride;\r\n\r\n        this.device = device;\r\n    }\r\n\r\n    appendBuffer(data: Float32Array){\r\n        this.arrays.push(data);\r\n        this.buffers.push(Pipeline.createGPUBuffer(this.device, data));\r\n    }\r\n\r\n    private createTransforms(){\r\n        mat4.identity(this.model_matrix);\r\n\r\n        const rotateXMat = mat4.create();\r\n        const rotateYMat = mat4.create();\r\n        const rotateZMat = mat4.create();\r\n        const translateMat = mat4.create();\r\n        const scaleMat = mat4.create();\r\n    \r\n        mat4.fromTranslation(translateMat, this.pos);\r\n        mat4.fromXRotation(rotateXMat, this.rotationAngles[0]);\r\n        mat4.fromYRotation(rotateYMat, this.rotationAngles[1]);\r\n        mat4.fromZRotation(rotateZMat, this.rotationAngles[2]);\r\n        mat4.fromScaling(scaleMat, this.scale);\r\n    \r\n        mat4.multiply(this.model_matrix, rotateXMat, scaleMat);\r\n        mat4.multiply(this.model_matrix, rotateYMat, this.model_matrix);\r\n        mat4.multiply(this.model_matrix, rotateZMat, this.model_matrix);\r\n        mat4.multiply(this.model_matrix, translateMat, this.model_matrix);\r\n    }\r\n\r\n    setBuffers(renderPass: GPURenderPassEncoder){\r\n        for(let i=0; i<this.buffers.length; i++) renderPass.setVertexBuffer(i, this.buffers[i]);\r\n    }\r\n\r\n}","import Mesh from \"./mesh\";\r\nimport Pipeline from \"./pipeline\";\r\nimport { vec3 } from \"gl-matrix\";\r\n\r\nexport default class IndexedMesh extends Mesh{\r\n    private indexes: Uint32Array;\r\n    private indexBuffer: GPUBuffer;\r\n\r\n    get numberOfVertex(){\r\n        return this.indexes.length;\r\n    }\r\n\r\n    constructor(device: GPUDevice, indexes:Uint32Array, stride: number = 3){\r\n        super(device, stride);\r\n\r\n        this.indexes = indexes;\r\n\r\n        this.indexBuffer = Pipeline.createGPUBufferUint(device, indexes);\r\n    }\r\n\r\n    setBuffers(renderPass: GPURenderPassEncoder){\r\n        super.setBuffers(renderPass);\r\n\r\n        renderPass.setIndexBuffer(this.indexBuffer, \"uint32\");\r\n    }\r\n\r\n    static calculateNormals(indexes: Uint32Array, vertices:Float32Array, vertLen: number = 3, offset: number = 0){\r\n        const normals = new Array(vertices.length / vertLen * 4).fill(0);\r\n\r\n        for(let i = 0; i<indexes.length; i+=3){\r\n            const tI1 = indexes[i];\r\n            const tI2 = indexes[i+1];\r\n            const tI3 = indexes[i+2];\r\n\r\n            const p1 = vec3.fromValues(\r\n                vertices[tI1*vertLen + offset ],\r\n                vertices[tI1*vertLen + offset +1],\r\n                vertices[tI1*vertLen + offset +2]\r\n            );\r\n\r\n            const p2 = vec3.fromValues(\r\n                vertices[tI2*vertLen + offset ],\r\n                vertices[tI2*vertLen + offset +1],\r\n                vertices[tI2*vertLen + offset +2]\r\n            );\r\n\r\n            const p3 = vec3.fromValues(\r\n                vertices[tI3*vertLen + offset ],\r\n                vertices[tI3*vertLen + offset +1],\r\n                vertices[tI3*vertLen + offset +2]\r\n            );\r\n\r\n            const normal = crossProduct(\r\n                vec3.fromValues(p2[0]-p1[0], p2[1] - p1[1], p2[2] - p1[2]),\r\n                vec3.fromValues(p3[0]-p1[0], p3[1] - p1[1], p3[2] - p1[2])\r\n            )\r\n\r\n            normals[tI1*4] += normal[0];\r\n            normals[tI1*4 + 1] += normal[1];\r\n            normals[tI1*4 + 2] += normal[2];\r\n\r\n            normals[tI2*4] += normal[0];\r\n            normals[tI2*4 + 1] += normal[1];\r\n            normals[tI2*4 + 2] += normal[2];\r\n\r\n            normals[tI3*4] += normal[0];\r\n            normals[tI3*4 + 1] += normal[1];\r\n            normals[tI3*4 + 2] += normal[2];\r\n        }\r\n        return new Float32Array(normals);\r\n    }\r\n}\r\n\r\nfunction crossProduct(v1: vec3, v2: vec3){\r\n    return vec3.fromValues(\r\n        v1[1]*v2[2] - v1[2]*v2[1],\r\n        v1[2]*v2[0] - v1[0]*v2[2],\r\n        v1[0]*v2[1] - v1[1]*v2[0]\r\n    );\r\n}","import IndexedMesh from \"./indexed_mesh\";\r\nimport Mesh from \"./mesh\";\r\nimport Pipeline from \"./pipeline\";\r\n\r\nexport default class Program{\r\n    private mesh?: Mesh;\r\n    private pipeline: Pipeline;\r\n\r\n    private uniforms: Uniform[] = [];\r\n    private bindGroups: BindGroupsSet = new BindGroupsSet();\r\n\r\n    device: GPUDevice;\r\n\r\n    constructor(device: GPUDevice, pipeline: Pipeline, mesh?: Mesh){\r\n        this.pipeline = pipeline;\r\n\r\n        if(mesh) {\r\n            this.mesh = mesh;\r\n\r\n        }\r\n\r\n        this.device = device;\r\n    }\r\n\r\n    appendUniformBuffer(binding: number, group: number, ...data: Float32Array[]){\r\n        if(data.length === 0) throw new Error(\"The data can't be undefined.\");\r\n\r\n        let size = 0;\r\n\r\n        const max = maxLength(data);\r\n        let blocks = 1;\r\n        let floats = 0;\r\n\r\n        for(const fArray of data){\r\n            if(floats + fArray.length > max){\r\n                blocks++;\r\n                floats = 0;\r\n            }\r\n\r\n            floats += fArray.length;\r\n        }\r\n\r\n        size = blocks * max * 4;\r\n\r\n        const uniformBuffer = this.device.createBuffer({\r\n            size,\r\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        const resource = {\r\n            buffer: uniformBuffer,\r\n            offset: 0,\r\n            size\r\n        } as GPUBindingResource;\r\n\r\n        this.bindGroups.add(this.device, binding, group, resource);\r\n\r\n        this.uniforms.push(new Uniform(uniformBuffer, data, max));\r\n\r\n        this.pipeline.setLayout(this.device.createPipelineLayout({\r\n            bindGroupLayouts: this.bindGroups.getLayouts()\r\n        }))\r\n    }\r\n\r\n    async setTexture(imgSrc: string, addressModeU:GPUAddressMode = \"repeat\", addressModeV:GPUAddressMode = \"repeat\"){\r\n        const img = document.createElement(\"img\");\r\n        img.src = imgSrc;\r\n        img.setAttribute('crossOrigin', '');\r\n        await img.decode();\r\n        const imageBitmap = await createImageBitmap(img);\r\n\r\n        const sampler = this.device.createSampler({\r\n            minFilter: 'linear',\r\n            magFilter: 'linear',\r\n            addressModeU,\r\n            addressModeV\r\n        });       \r\n    \r\n        // create texture\r\n        const texture = this.device.createTexture({\r\n            size: [imageBitmap.width, imageBitmap.height, 1],\r\n            format: 'rgba8unorm',\r\n            usage: GPUTextureUsage.TEXTURE_BINDING | \r\n                   GPUTextureUsage.COPY_DST | \r\n                   GPUTextureUsage.RENDER_ATTACHMENT\r\n        });\r\n    \r\n        this.device.queue.copyExternalImageToTexture(\r\n            { source: imageBitmap },\r\n            { texture: texture },\r\n            [imageBitmap.width, imageBitmap.height]\r\n        );\r\n    \r\n        this.bindGroups.add(this.device, 0, 1, texture.createView());\r\n        this.bindGroups.add(this.device, 1, 1, sampler);\r\n\r\n        this.pipeline.setLayout(this.device.createPipelineLayout({\r\n            bindGroupLayouts: this.bindGroups.getLayouts()\r\n        }))\r\n    }\r\n\r\n    private setBindGroups(renderPass: GPURenderPassEncoder){\r\n        for(const entry of this.bindGroups.groups.entries()){\r\n            renderPass.setBindGroup(Number(entry[0]), entry[1].group!);\r\n        }\r\n    }\r\n\r\n    private writeUniforms(){\r\n        for(const uniform of this.uniforms){\r\n            let offset = 0;\r\n            let blockLen = 0;\r\n            let block = 0;\r\n\r\n            for(const data of uniform.information){\r\n                if(blockLen + data.length > uniform.max){\r\n                    block++;\r\n                    blockLen = 0;\r\n                    offset = block * uniform.max * 4;\r\n                }\r\n\r\n                this.device.queue.writeBuffer(uniform.buffer, offset, data as ArrayBuffer);\r\n\r\n                blockLen += data.length;\r\n                offset += data.length*4;\r\n            }\r\n        }\r\n    }\r\n\r\n    private getRenderPass(encoder: GPUCommandEncoder, context:GPUCanvasContext, depthTexture?: GPUTexture){\r\n        const descriptor = {\r\n            colorAttachments:[\r\n                {\r\n                    clearValue:[0.0, 0.0, 0.0, 1.0],\r\n                    storeOp:\"store\",\r\n                    loadOp:\"clear\",\r\n                    view: context!.getCurrentTexture().createView()\r\n                }\r\n            ],\r\n        } as GPURenderPassDescriptor;\r\n\r\n\r\n        if(this.pipeline.depth){\r\n            if(!depthTexture)\r\n                throw new Error(\"Depth texture is needed.\");\r\n\r\n            const depthStencilAttachment={\r\n                view: depthTexture!.createView(),\r\n                depthStoreOp: \"store\",\r\n                depthClearValue: 1.0,\r\n                depthLoadOp: \"clear\"\r\n            } as GPURenderPassDepthStencilAttachment;\r\n\r\n            descriptor.depthStencilAttachment = depthStencilAttachment;\r\n        }\r\n\r\n        const renderPass=encoder.beginRenderPass(descriptor);\r\n\r\n        return renderPass;\r\n    }\r\n\r\n    draw(context: GPUCanvasContext, depthTexture?: GPUTexture, n_vertex?: number){\r\n        if(!(this.mesh || n_vertex))\r\n            throw new Error(\"unknown number of vertices.\");\r\n\r\n        this.writeUniforms();\r\n        \r\n        const commandEncoder = this.device.createCommandEncoder();\r\n        const renderPass = this.getRenderPass(commandEncoder, context, depthTexture);\r\n\r\n        renderPass.setPipeline(this.pipeline.renderPipeline!);\r\n\r\n        if(this.mesh) this.mesh.setBuffers(renderPass);\r\n        \r\n        this.setBindGroups(renderPass);\r\n        \r\n        if(this.mesh && this.mesh instanceof IndexedMesh){\r\n            renderPass.drawIndexed(this.mesh!.numberOfVertex);\r\n        }else{\r\n            renderPass.draw(this.mesh!.numberOfVertex || n_vertex!);\r\n        }\r\n\r\n        renderPass.end();\r\n\r\n        this.device.queue.submit([commandEncoder.finish()]);\r\n    }\r\n}\r\n\r\nclass Uniform{\r\n    buffer: GPUBuffer;\r\n    information: Float32Array[];\r\n    max: number;\r\n\r\n    constructor(buffer: GPUBuffer, info: Float32Array[], max: number){\r\n        this.buffer = buffer;\r\n        this.information = info;\r\n        this.max = max;\r\n    }\r\n}\r\n\r\nfunction maxLength(data: Float32Array[]){\r\n    let max = 0;\r\n\r\n    for(let array of data){\r\n        if(array.length>max) max = array.length;\r\n    }\r\n\r\n    return max;\r\n}\r\n\r\nclass BindGroupsSet{\r\n    groups: Map<number, BindGroup> = new Map();\r\n\r\n    add(device: GPUDevice, binding: number, group: number, resource: GPUBindingResource){\r\n        if(!this.groups.get(group)) this.groups.set(group, new BindGroup());\r\n\r\n        this.groups.get(group)?.newEntry(device, binding, resource);\r\n    }\r\n\r\n    getLayouts(){\r\n        const layouts: GPUBindGroupLayout[] = [];\r\n\r\n        for(let group of this.groups.values()){\r\n            layouts.push(group.layout!);\r\n        }\r\n\r\n        return layouts;\r\n    }\r\n}\r\n\r\nclass BindGroup{\r\n    layoutEntries: Map<number, GPUBindGroupLayoutEntry> = new Map();\r\n    entries: Map<number, GPUBindGroupEntry> = new Map();\r\n\r\n    layout?: GPUBindGroupLayout;\r\n    group?: GPUBindGroup;\r\n\r\n    newEntry(device: GPUDevice, binding: number, resource: GPUBindingResource){\r\n        const layEntry = BindGroup.getLayoutEntry(resource);\r\n        layEntry.binding = binding;\r\n        this.layoutEntries.set(binding, layEntry);\r\n        \r\n        this.entries.set(binding, {\r\n            binding: binding,\r\n            resource\r\n        });\r\n\r\n        this.layout = device.createBindGroupLayout({\r\n            entries: this.layoutEntries.values()\r\n        })\r\n\r\n        this.group = device.createBindGroup({\r\n            layout: this.layout,\r\n            entries: this.entries.values()\r\n        })\r\n    }\r\n\r\n    private static getLayoutEntry (resource:  GPUBindingResource): GPUBindGroupLayoutEntry{\r\n        if(resource instanceof GPUTextureView){\r\n            return {\r\n                binding: -1,\r\n                visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\r\n                texture: {}\r\n            }\r\n        }\r\n        if(resource instanceof GPUSampler){\r\n            return {\r\n                binding: -1,\r\n                visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\r\n                sampler: {}\r\n            }\r\n        }\r\n        \r\n        return {\r\n            binding: -1,\r\n            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\r\n            buffer: {}\r\n        }    \r\n    }\r\n}","export default class GPUParams{\r\n    device?: GPUDevice;\r\n    private on = false;\r\n\r\n    async init(){\r\n        if(!navigator.gpu) throw(\"Seu navegador atual no suporta webGPU!\");\r\n    \r\n        const adapter = await navigator.gpu?.requestAdapter() as GPUAdapter;\r\n        this.device = await adapter?.requestDevice() as GPUDevice;\r\n    }\r\n\r\n    getCanvasParams(canvas: HTMLCanvasElement){\r\n        const devicePixelRatio = window.devicePixelRatio || 1;\r\n        canvas.width = 1024 * devicePixelRatio;\r\n        canvas.height = 768 * devicePixelRatio;\r\n\r\n        const context = canvas.getContext(\"webgpu\") as unknown as GPUCanvasContext;\r\n\r\n        context.configure({\r\n            device: this.device!,\r\n            format:\"bgra8unorm\",\r\n            alphaMode:\"premultiplied\"\r\n        });\r\n    \r\n        const depthTexture = this.device!.createTexture({\r\n            format: \"depth24plus\",\r\n            usage: GPUTextureUsage.RENDER_ATTACHMENT,\r\n            size: [canvas!.width, canvas!.height, 1]\r\n        });\r\n\r\n        return {\r\n            context,\r\n            depthTexture\r\n        };\r\n    }\r\n\r\n    static async build(): Promise<GPUParams>{\r\n        const nova = new GPUParams();\r\n        await nova.init();\r\n        \r\n        return nova;\r\n    }\r\n}","import { Shaders } from \"./shader\";\r\nimport { CubeData } from \"./vertex_data\";\r\nimport Camera from \"./camera\";\r\nimport Mesh from \"./webgpu/mesh\";\r\nimport Pipeline from \"./webgpu/pipeline\";\r\nimport Program from \"./webgpu/program\";\r\nimport { mat4 } from \"gl-matrix\";\r\nimport GPUParams from \"./webgpu/gpu_params\";\r\n\r\nGPUParams.build().then((gpu)=>{\r\n    const cubeData = CubeData();\r\n\r\n    const canvas = document.querySelector(\"#canvas-webgpu\") as HTMLCanvasElement;\r\n    const canvasParams = gpu.getCanvasParams(canvas);\r\n\r\n    const cube = new Mesh(gpu.device!, 3);\r\n    cube.appendBuffer(cubeData.positions);\r\n    cube.appendBuffer(cubeData.colors);\r\n    const shaders = Shaders();\r\n\r\n    const pipeline = new Pipeline(gpu.device!, shaders.vertex, shaders.fragment, \"triangle-list\");\r\n    pipeline.enableDepthTest();\r\n    pipeline.addVertexBuffer({location: 0});\r\n    pipeline.addVertexBuffer({location: 1});\r\n\r\n    const camera = new Camera(canvas);\r\n    camera.projectionType = \"orthogonal\";\r\n    camera.camPosition = [2, 2, -6];\r\n\r\n    const program = new Program(gpu.device!, pipeline, cube);\r\n\r\n    const mvp = mat4.create();\r\n    mat4.multiply(mvp, camera.getViewProjection(), cube.modelMatrix);\r\n    \r\n    program.appendUniformBuffer(0, 0, new Float32Array(mvp));\r\n\r\n    program.draw(canvasParams.context, canvasParams.depthTexture);\r\n\r\n    document.addEventListener(\"keypress\", e=>{\r\n        if (e.key == \"p\") {\r\n            camera.projectionType = \"perspective\";\r\n            mat4.multiply(mvp, camera.getViewProjection(), cube.modelMatrix);\r\n\r\n            program.appendUniformBuffer(0, 0, new Float32Array(mvp));\r\n            program.draw(canvasParams.context, canvasParams.depthTexture);\r\n        } else if (e.key == \"o\") {\r\n            camera.projectionType = \"orthogonal\";\r\n            mat4.multiply(mvp, camera.getViewProjection(), cube.modelMatrix);\r\n\r\n            program.appendUniformBuffer(0, 0, new Float32Array(mvp));\r\n            program.draw(canvasParams.context, canvasParams.depthTexture);\r\n        }\r\n    })\r\n})\r\n\r\n","export const CubeData=()=>{\r\n    const positions = new Float32Array([\r\n        //front\r\n        -1, -1,  1,  \r\n         1, -1,  1,  \r\n         1,  1,  1,\r\n         1,  1,  1,\r\n        -1,  1,  1,\r\n        -1, -1,  1,\r\n\r\n        // right\r\n         1, -1,  1,\r\n         1, -1, -1,\r\n         1,  1, -1,\r\n         1,  1, -1,\r\n         1,  1,  1,\r\n         1, -1,  1,\r\n\r\n        // back\r\n        -1, -1, -1,\r\n        -1,  1, -1,\r\n         1,  1, -1,\r\n         1,  1, -1,\r\n         1, -1, -1,\r\n        -1, -1, -1,\r\n\r\n        // left\r\n        -1, -1,  1,\r\n        -1,  1,  1,\r\n        -1,  1, -1,\r\n        -1,  1, -1,\r\n        -1, -1, -1,\r\n        -1, -1,  1,\r\n\r\n        // top\r\n        -1,  1,  1,\r\n         1,  1,  1,\r\n         1,  1, -1,\r\n         1,  1, -1,\r\n        -1,  1, -1,\r\n        -1,  1,  1,\r\n\r\n        // bottom\r\n        -1, -1,  1,\r\n        -1, -1, -1,\r\n         1, -1, -1,\r\n         1, -1, -1,\r\n         1, -1,  1,\r\n        -1, -1,  1\r\n    ]);\r\n\r\n    const colors = new Float32Array([\r\n        // front - blue\r\n        0, 0, 1,\r\n        0, 0, 1,\r\n        0, 0, 1,\r\n        0, 0, 1,\r\n        0, 0, 1,\r\n        0, 0, 1,\r\n\r\n        // right - red\r\n        1, 0, 0,\r\n        1, 0, 0,\r\n        1, 0, 0,\r\n        1, 0, 0,\r\n        1, 0, 0,\r\n        1, 0, 0,\r\n\r\n        //back - yellow\r\n        1, 1, 0,\r\n        1, 1, 0,\r\n        1, 1, 0,\r\n        1, 1, 0,\r\n        1, 1, 0,\r\n        1, 1, 0,\r\n\r\n        //left - aqua\r\n        0, 1, 1,\r\n        0, 1, 1,\r\n        0, 1, 1,\r\n        0, 1, 1,\r\n        0, 1, 1,\r\n        0, 1, 1,\r\n\r\n        // top - green\r\n        0, 1, 0,\r\n        0, 1, 0,\r\n        0, 1, 0,\r\n        0, 1, 0,\r\n        0, 1, 0,\r\n        0, 1, 0,\r\n\r\n        // bottom - fuchsia\r\n        1, 0, 1,\r\n        1, 0, 1,\r\n        1, 0, 1,\r\n        1, 0, 1,\r\n        1, 0, 1,\r\n        1, 0, 1\r\n    ]);\r\n\r\n    return {\r\n        positions,\r\n        colors\r\n    }\r\n}","export const Shaders=() =>{\r\n    const vertex=`\r\n        @group(0) @binding(0)\r\n            var<uniform> mvpMatrix: mat4x4<f32>;\r\n\r\n        struct Input{\r\n            @location(0) position: vec4<f32>,\r\n            @location(1) vColor: vec4<f32>,\r\n        }\r\n\r\n        struct Output{\r\n            @builtin(position) position: vec4<f32>,\r\n            @location(0) vColor: vec4<f32>,\r\n        }\r\n\r\n        @vertex\r\n        fn main(in: Input) -> Output {\r\n            var out: Output;\r\n            //var uniforms: Uniforms;\r\n\r\n            out.position = mvpMatrix * in.position;\r\n            out.vColor = in.vColor;\r\n\r\n            return out;\r\n        }\r\n    `\r\n    const fragment=`  \r\n        @fragment\r\n        fn main(@location(0) vColor: vec4<f32>) -> @location(0) vec4<f32> {\r\n            return vColor;\r\n        }\r\n    `\r\n\r\n    return {\r\n        vertex, fragment\r\n    };\r\n}\r\n\r\n"],"names":["EPSILON","ARRAY_TYPE","Float32Array","Array","create","out","identity","multiply","a","b","a00","a01","a02","a03","a10","a11","a12","a13","a20","a21","a22","a23","a30","a31","a32","a33","b0","b1","b2","b3","Math","random","PI","hypot","y","i","arguments","length","sqrt","Camera","constructor","canvas","viewMatrix","projMatrix","viewProjMatrix","camPosition","lookDirection","upDirection","left","right","bottom","top","near","far","fovy","typeOfProjection","this","aspect","width","height","projectionType","type","Error","updateViewMatrix","eye","center","up","x0","x1","x2","y0","y1","y2","z0","z1","z2","len","eyex","eyey","eyez","upx","upy","upz","centerx","centery","centerz","abs","updateProjMatrix","nf","f","tan","Infinity","lr","bt","getViewProjection","x","z","Pipeline","device","vertShader","fragShader","primitive","indexFormat","buffers","changed","_depth","pipelineDescriptor","vertex","module","createShaderModule","code","entryPoint","fragment","targets","format","topology","stripIndexFormat","layout","depth","enableDepthTest","depthStencil","depthWriteEnabled","depthCompare","setLayout","addVertexBuffer","atributes","buffer","atribs","stride","atribute","push","shaderLocation","location","offset","arrayStride","attributes","includes","Number","slice","renderPipeline","render_pipeline","createRenderPipeline","createGPUBuffer","data","usageFlag","GPUBufferUsage","VERTEX","COPY_DST","createBuffer","size","byteLength","usage","mappedAtCreation","getMappedRange","set","unmap","createGPUBufferUint","INDEX","Uint32Array","Mesh","arrays","pos","scale","rotationAngles","model_matrix","modelMatrix","createTransforms","numberOfVertex","appendBuffer","rotateXMat","rotateYMat","rotateZMat","translateMat","scaleMat","v","rad","s","sin","c","cos","setBuffers","renderPass","setVertexBuffer","IndexedMesh","indexes","super","indexBuffer","setIndexBuffer","static","vertices","vertLen","normals","fill","tI1","tI2","tI3","p1","p2","p3","normal","v1","v2","Program","pipeline","mesh","uniforms","bindGroups","BindGroupsSet","appendUniformBuffer","binding","group","max","array","maxLength","blocks","floats","fArray","uniformBuffer","UNIFORM","resource","add","Uniform","createPipelineLayout","bindGroupLayouts","getLayouts","setTexture","imgSrc","addressModeU","addressModeV","img","document","createElement","src","setAttribute","decode","imageBitmap","createImageBitmap","sampler","createSampler","minFilter","magFilter","texture","createTexture","GPUTextureUsage","TEXTURE_BINDING","RENDER_ATTACHMENT","queue","copyExternalImageToTexture","source","createView","setBindGroups","entry","groups","entries","setBindGroup","writeUniforms","uniform","blockLen","block","information","writeBuffer","getRenderPass","encoder","context","depthTexture","descriptor","colorAttachments","clearValue","storeOp","loadOp","view","getCurrentTexture","depthStencilAttachment","depthStoreOp","depthClearValue","depthLoadOp","beginRenderPass","draw","n_vertex","commandEncoder","createCommandEncoder","setPipeline","drawIndexed","end","submit","finish","info","Map","get","BindGroup","newEntry","layouts","values","layoutEntries","layEntry","getLayoutEntry","createBindGroupLayout","createBindGroup","GPUTextureView","visibility","GPUShaderStage","FRAGMENT","GPUSampler","GPUParams","on","init","navigator","gpu","adapter","requestAdapter","requestDevice","getCanvasParams","devicePixelRatio","window","getContext","configure","alphaMode","nova","build","then","cubeData","positions","colors","querySelector","canvasParams","cube","shaders","camera","program","mvp","addEventListener","e","key"],"sourceRoot":""}