{"version":3,"file":"main.bundle.js","mappings":"mBAAO,MAKMA,EAAQ,KAAU,O,OAAA,E,OAAA,E,EAAA,Y,MAC3B,MAAMC,EALHC,UAAUC,IAAW,mBACjB,uBAMP,GAAc,yBAAXF,EAEC,MADAG,QAAQC,IAAIJ,GACP,0CAGT,MAAMK,EAASC,SAASC,cAAc,kBAEhCC,EAAmBC,OAAOD,kBAAoB,EACpDH,EAAOK,MAAQ,KAAOF,EACtBH,EAAOM,OAAS,IAAMH,EAEtB,MAAMI,QAA6B,QAAb,EAAAX,UAAUC,WAAG,eAAEW,iBAC/BC,QAAeF,aAAO,EAAPA,EAASG,gBACxBC,EAAUX,EAAOY,WAAW,UAE5BC,EAAgB,aAOtB,OANAF,EAAQG,UAAU,CACdL,SACAM,OAAOF,EACPG,UAAU,kBAGP,CAACP,SAAQT,SAAQa,kBAAiBF,UAC7C,E,YA1B+B,K,6QA0B9B,E,UC5B2B,YACxB,MAAMd,QAAUH,IACVe,EAAOZ,EAAIY,OAEXQ,EAAW,IAAIC,aAAa,EAC7B,IAAM,GAAS,EAAE,EAAE,EACpB,IAAM,GAAU,EAAE,EAAE,EACpB,GAAK,GAAW,EAAE,EAAE,GACnB,GAAK,GAAU,EAAE,EAAE,IAGlBC,EAAU,IAAIC,YAAY,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,IAE1CC,EDiBmB,EAACZ,EAAmBa,EAC7CC,EAA8BC,eAAeC,OAASD,eAAeE,YACjE,MAAMC,EAAOlB,EAAOmB,aAAa,CAC7BC,KAAKP,EAAKQ,WACVC,MAAMR,EACNS,kBAAiB,IAIrB,OAFA,IAAId,aAAaS,EAAOM,kBAAkBC,IAAIZ,GAC9CK,EAAOQ,QACAR,CAAM,EC1BES,CAAgB3B,EAAQQ,GACrCoB,ED4BuB,EAAC5B,EAAmBa,EACjDC,EAA8BC,eAAec,MAAOd,eAAeE,YAC/D,MAAMC,EAAOlB,EAAOmB,aAAa,CAC7BC,KAAKP,EAAKQ,WACVC,MAAMR,EACNS,kBAAiB,IAIrB,OAFA,IAAIZ,YAAYO,EAAOM,kBAAkBC,IAAIZ,GAC7CK,EAAOQ,QACAR,CAAM,ECrCCY,CAAoB9B,EAAQU,GAExCqB,EClBO,qdDkBPA,ECCS,kJDATC,EAAWhC,EAAOiC,qBAAqB,CACzCC,OAAO,CACHC,OAAOnC,EAAOoC,mBAAmB,CAC7BC,KAAKN,IAETO,WAAW,OACXC,QAAQ,CACJ,CACIC,YAAY,GACZC,WAAW,CAAC,CACRC,eAAe,EACfpC,OAAO,YACPqC,OAAO,GACT,CACED,eAAe,EACfpC,OAAO,YACPqC,OAAO,OAKvBC,SAAS,CACLT,OAAOnC,EAAOoC,mBAAmB,CAC7BC,KAAKN,IAETO,WAAW,OACXO,QAAQ,CAAC,CACLvC,OAAOlB,EAAIgB,mBAGnB0C,UAAU,CACNC,SAAS,iBAEbC,OAAO,SAGLC,EAAejD,EAAOkD,uBACtBC,EAAY/D,EAAIc,QAAQkD,oBAAoBC,aAE5CC,EAAWL,EAAeM,gBAAgB,CAC5CC,iBAAiB,CAAC,CACdC,WAAW,CAAC,EAAK,EAAK,EAAK,GAC3BC,QAAQ,QACRC,OAAO,QACPC,KAAMT,MAGdG,EAAWO,YAAY7B,GACvBsB,EAAWQ,gBAAgB,EAAGlD,GAC9B0C,EAAWS,eAAenC,EAAa,UACvC0B,EAAWU,YAAY,GACvBV,EAAWW,MAEXjE,EAAOkE,MAAMC,OAAO,CAAClB,EAAemB,UACxC,E,YAvE4B,K,kPAAA,E","sources":["webpack://webgpu/./src/helper.ts","webpack://webgpu/./src/main.ts","webpack://webgpu/./src/shader.ts"],"sourcesContent":["export const checkWebGPU=()=>{\r\n    if(navigator.gpu)return \"webGPU suportado\"\r\n    return \"webGPU não suportado\"\r\n}\r\n\r\nexport const initGPU=async ()=>{\r\n    const checkGpu=checkWebGPU();\r\n\r\n    if(checkGpu===\"webGPU não suportado\"){\r\n        console.log(checkGpu);\r\n        throw(\"Seu navegador atual não suporta webGPU!\");\r\n    }\r\n\r\n    const canvas = document.querySelector(\"#canvas-webgpu\") as HTMLCanvasElement;\r\n\r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n    canvas.width = 1024 * devicePixelRatio;\r\n    canvas.height = 768 * devicePixelRatio;\r\n\r\n    const adapter = await navigator.gpu?.requestAdapter() as GPUAdapter;\r\n    const device = await adapter?.requestDevice() as GPUDevice;\r\n    const context = canvas.getContext(\"webgpu\") as unknown as GPUCanvasContext;\r\n\r\n    const swapChainFormat='bgra8unorm';\r\n    context.configure({\r\n        device,\r\n        format:swapChainFormat,\r\n        alphaMode:\"premultiplied\"\r\n    })\r\n\r\n    return {device, canvas, swapChainFormat, context}\r\n}\r\n\r\nexport const createGPUBuffer=(device: GPUDevice, data: Float32Array, \r\n    usageFlag:GPUBufferUsageFlags=GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST)=>{\r\n        const buffer=device.createBuffer({\r\n            size:data.byteLength,\r\n            usage:usageFlag,\r\n            mappedAtCreation:true\r\n        });\r\n        new Float32Array(buffer.getMappedRange()).set(data);\r\n        buffer.unmap();\r\n        return buffer;\r\n}\r\n\r\nexport const createGPUBufferUint=(device: GPUDevice, data: Uint32Array, \r\n    usageFlag:GPUBufferUsageFlags=GPUBufferUsage.INDEX| GPUBufferUsage.COPY_DST)=>{\r\n        const buffer=device.createBuffer({\r\n            size:data.byteLength,\r\n            usage:usageFlag,\r\n            mappedAtCreation:true\r\n        });\r\n        new Uint32Array(buffer.getMappedRange()).set(data);\r\n        buffer.unmap();\r\n        return buffer;\r\n}","import { initGPU, createGPUBuffer, createGPUBufferUint } from \"./helper\";\r\nimport { Shaders } from \"./shader\";\r\n\r\nconst createSquare=async()=>{\r\n    const gpu=await initGPU();\r\n    const device=gpu.device;\r\n    \r\n    const vertexData=new Float32Array([\r\n        -0.5, -0.5,     1,0,0,\r\n        0.5, -0.5,      0,1,0,\r\n        0.5, 0.5,       1,0,0,\r\n        -0.5, 0.5,      0,0,1,\r\n    ]);\r\n\r\n    const indexData=new Uint32Array([0, 1, 3, 3, 1, 2]);\r\n\r\n    const vertexBuffer=createGPUBuffer(device, vertexData);\r\n    const indexBuffer=createGPUBufferUint(device, indexData);\r\n\r\n    const shaders=Shaders();\r\n    const pipeline = device.createRenderPipeline({\r\n        vertex:{\r\n            module:device.createShaderModule({\r\n                code:shaders.vertex\r\n            }),\r\n            entryPoint:\"main\",\r\n            buffers:[\r\n                {\r\n                    arrayStride:4*(2+3),\r\n                    attributes:[{\r\n                        shaderLocation:0,\r\n                        format:\"float32x2\",\r\n                        offset:0\r\n                    },{\r\n                        shaderLocation:1,\r\n                        format:\"float32x3\",\r\n                        offset:8\r\n                    }]\r\n                }\r\n            ]\r\n        },\r\n        fragment:{\r\n            module:device.createShaderModule({\r\n                code:shaders.fragment\r\n            }),\r\n            entryPoint:\"main\",\r\n            targets:[{\r\n                format:gpu.swapChainFormat as GPUTextureFormat\r\n            }]\r\n        },\r\n        primitive:{\r\n            topology:\"triangle-list\"\r\n        },\r\n        layout:'auto'\r\n    })\r\n\r\n    const commandEncoder=device.createCommandEncoder();\r\n    const textureView=gpu.context.getCurrentTexture().createView();\r\n\r\n    const renderPass=commandEncoder.beginRenderPass({\r\n        colorAttachments:[{\r\n            clearValue:[0.0, 0.0, 0.0, 1.0],\r\n            storeOp:\"store\",\r\n            loadOp:\"clear\",\r\n            view: textureView\r\n        }]\r\n    });\r\n    renderPass.setPipeline(pipeline);\r\n    renderPass.setVertexBuffer(0, vertexBuffer);\r\n    renderPass.setIndexBuffer(indexBuffer, \"uint32\")\r\n    renderPass.drawIndexed(6);\r\n    renderPass.end();\r\n\r\n    device.queue.submit([commandEncoder.finish()]);\r\n}\r\n\r\ncreateSquare();\r\n","export const Shaders=()=>{\r\n    const vertex=`\r\n        struct Input{\r\n            @location(0) position: vec4<f32>,\r\n            @location(1) vColor: vec4<f32>,\r\n        }\r\n\r\n        struct Output{\r\n            @builtin(position) position: vec4<f32>,\r\n            @location(0) vColor: vec4<f32>,\r\n        }\r\n\r\n        @vertex\r\n        fn main(in: Input) -> Output {\r\n            var out: Output;\r\n            out.position=in.position;\r\n            out.vColor=in.vColor;\r\n            return out;\r\n        }\r\n    `\r\n    const fragment=`  \r\n        @fragment\r\n        fn main(@location(0) vColor: vec4<f32>) -> @location(0) vec4<f32> {\r\n            return vColor;\r\n        }\r\n    `\r\n\r\n\r\n    return {vertex, fragment};\r\n}"],"names":["initGPU","checkGpu","navigator","gpu","console","log","canvas","document","querySelector","devicePixelRatio","window","width","height","adapter","requestAdapter","device","requestDevice","context","getContext","swapChainFormat","configure","format","alphaMode","vertexData","Float32Array","indexData","Uint32Array","vertexBuffer","data","usageFlag","GPUBufferUsage","VERTEX","COPY_DST","buffer","createBuffer","size","byteLength","usage","mappedAtCreation","getMappedRange","set","unmap","createGPUBuffer","indexBuffer","INDEX","createGPUBufferUint","shaders","pipeline","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","fragment","targets","primitive","topology","layout","commandEncoder","createCommandEncoder","textureView","getCurrentTexture","createView","renderPass","beginRenderPass","colorAttachments","clearValue","storeOp","loadOp","view","setPipeline","setVertexBuffer","setIndexBuffer","drawIndexed","end","queue","submit","finish"],"sourceRoot":""}