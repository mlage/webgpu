(()=>{"use strict";var t,e=1e-6,i="undefined"!=typeof Float32Array?Float32Array:Array;function r(t,e,r,s){var n=new i(4);return n[0]=t,n[1]=e,n[2]=r,n[3]=s,n}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)}),t=new i(4),i!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0);class s{constructor(t){this.ambColor=r(.2,.2,.2,1),this.ambK=2,this.difColor=r(0,.2,.5,1),this.difK=7,this.espColor=r(1,0,1,1),this.espK=2,this.espExp=3,this.pos=t}createUniformBuffer(t,e,i){t.appendUniformBuffer(i,e,new Float32Array(this.ambColor),new Float32Array(this.difColor),new Float32Array(this.espColor),new Float32Array(this.pos),new Float32Array([this.ambK]),new Float32Array([this.difK]),new Float32Array([this.espK]),new Float32Array([this.espExp]))}newPos(t){this.pos=r(4*Math.cos(t),0,4*Math.sin(t),1)}}function n(t,e,r){var s=new i(3);return s[0]=t,s[1]=e,s[2]=r,s}!function(){var t=new i(3);i!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0)}();class o{constructor(t=1,e=n(0,0,0)){this.radius=t,this.center=e,this.generateData(30,30)}get indexes(){return this._indexes}get vertices(){return this._vertices}generateData(t,e){t<2&&(t=2),e<2&&(e=2);let i,r=[];for(let s=0;s<t;s++)for(let n=0;n<e;n++)i=this.getPoint(180*s/(t-1),360*n/(e-1)),i=[...i,0,0,1],r.push(i);let s,n,o,a,h=[];for(let i=0;i<t-1;i++)for(let t=0;t<e-1;t++)s=i*e+t,n=(i+1)*e+t,o=i*e+t+1,a=(i+1)*e+t+1,h.push([s,n,o,n,a,o]);this._vertices=new Float32Array(r.flat()),this._indexes=new Uint32Array(h.flat())}getPoint(t,e){const i=Math.sin(t*Math.PI/180),r=Math.cos(t*Math.PI/180),s=Math.sin(e*Math.PI/180),n=Math.cos(e*Math.PI/180);return[this.radius*i*n+this.center[0],this.radius*r+this.center[1],-this.radius*s*i+this.center[2]]}}function a(){var t=new i(16);return i!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}function h(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function c(t,e,i){var r=e[0],s=e[1],n=e[2],o=e[3],a=e[4],h=e[5],c=e[6],u=e[7],f=e[8],l=e[9],p=e[10],d=e[11],m=e[12],v=e[13],x=e[14],g=e[15],w=i[0],y=i[1],P=i[2],b=i[3];return t[0]=w*r+y*a+P*f+b*m,t[1]=w*s+y*h+P*l+b*v,t[2]=w*n+y*c+P*p+b*x,t[3]=w*o+y*u+P*d+b*g,w=i[4],y=i[5],P=i[6],b=i[7],t[4]=w*r+y*a+P*f+b*m,t[5]=w*s+y*h+P*l+b*v,t[6]=w*n+y*c+P*p+b*x,t[7]=w*o+y*u+P*d+b*g,w=i[8],y=i[9],P=i[10],b=i[11],t[8]=w*r+y*a+P*f+b*m,t[9]=w*s+y*h+P*l+b*v,t[10]=w*n+y*c+P*p+b*x,t[11]=w*o+y*u+P*d+b*g,w=i[12],y=i[13],P=i[14],b=i[15],t[12]=w*r+y*a+P*f+b*m,t[13]=w*s+y*h+P*l+b*v,t[14]=w*n+y*c+P*p+b*x,t[15]=w*o+y*u+P*d+b*g,t}class u{constructor(t){this.view_matrix=a(),this.proj_matrix=a(),this.viewProjMatrix=a(),this.camPosition=[0,0,1],this.lookDirection=[0,0,0],this.upDirection=[0,1,0],this.left=-4,this.right=4,this.bottom=-4,this.top=4,this.near=1,this.far=9,this.fovy=Math.PI/2,this.typeOfProjection="perspective",this.aspect=t.width/t.height}set projectionType(t){if("orthogonal"!==t&&"perspective"!==t)throw new Error("Invalid type of projection.");this.typeOfProjection=t}get viewMatrix(){return this.updateViewMatrix(),this.view_matrix}get projMatrix(){return this.updateProjMatrix(),this.proj_matrix}updateViewMatrix(){h(this.view_matrix),function(t,i,r,s){var n,o,a,c,u,f,l,p,d,m,v=i[0],x=i[1],g=i[2],w=s[0],y=s[1],P=s[2],b=r[0],M=r[1],_=r[2];Math.abs(v-b)<e&&Math.abs(x-M)<e&&Math.abs(g-_)<e?h(t):(l=v-b,p=x-M,d=g-_,n=y*(d*=m=1/Math.hypot(l,p,d))-P*(p*=m),o=P*(l*=m)-w*d,a=w*p-y*l,(m=Math.hypot(n,o,a))?(n*=m=1/m,o*=m,a*=m):(n=0,o=0,a=0),c=p*a-d*o,u=d*n-l*a,f=l*o-p*n,(m=Math.hypot(c,u,f))?(c*=m=1/m,u*=m,f*=m):(c=0,u=0,f=0),t[0]=n,t[1]=c,t[2]=l,t[3]=0,t[4]=o,t[5]=u,t[6]=p,t[7]=0,t[8]=a,t[9]=f,t[10]=d,t[11]=0,t[12]=-(n*v+o*x+a*g),t[13]=-(c*v+u*x+f*g),t[14]=-(l*v+p*x+d*g),t[15]=1)}(this.view_matrix,this.camPosition,this.lookDirection,this.upDirection)}updateProjMatrix(){h(this.proj_matrix),"perspective"==this.typeOfProjection?function(t,e,i,r,s){var n,o=1/Math.tan(e/2);t[0]=o/i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=s&&s!==1/0?(n=1/(r-s),t[10]=(s+r)*n,t[14]=2*s*r*n):(t[10]=-1,t[14]=-2*r)}(this.proj_matrix,this.fovy,this.aspect,this.near,this.far):function(t,e,i,r,s,n,o){var a=1/(e-i),h=1/(r-s),c=1/(n-o);t[0]=-2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*h,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*c,t[11]=0,t[12]=(e+i)*a,t[13]=(s+r)*h,t[14]=(o+n)*c,t[15]=1}(this.proj_matrix,1024*this.left/768,1024*this.right/768,this.bottom,this.top,this.near,this.far)}getViewProjection(){return this.updateViewMatrix(),this.updateProjMatrix(),h(this.viewProjMatrix),c(this.viewProjMatrix,this.proj_matrix,this.view_matrix),this.viewProjMatrix}}class f{constructor(t,e,i,r){let s;this.buffers=[],this.changed=!0,this._depth=!1,"line-strip"===r&&(s="uint32"),this.pipelineDescriptor={vertex:{module:t.createShaderModule({code:e}),entryPoint:"main",buffers:[{arrayStride:24,attributes:[{shaderLocation:0,format:"float32x3",offset:0},{shaderLocation:1,format:"float32x3",offset:12}]},{arrayStride:16,attributes:[{shaderLocation:2,format:"float32x4",offset:0}]}]},fragment:{module:t.createShaderModule({code:i}),entryPoint:"main",targets:[{format:"bgra8unorm"}]},primitive:{topology:r,stripIndexFormat:s},layout:"auto"};"point-list"!==r&&"line-list"!==r&&"line-strip"!==r&&(this.pipelineDescriptor.depthStencil={format:"depth24plus",depthWriteEnabled:!0,depthCompare:"less"},this._depth=!0),this.device=t}get depth(){return this._depth}setLayout(t){this.changed=!0,this.pipelineDescriptor.layout=t}addVertexBuffer(...t){this.changed=!0;for(const e of t)e.format}get renderPipeline(){return this.changed&&(this.render_pipeline=this.device.createRenderPipeline(this.pipelineDescriptor),this.changed=!1),this.render_pipeline}}f.createGPUBuffer=(t,e,i=GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST)=>{const r=t.createBuffer({size:e.byteLength,usage:i,mappedAtCreation:!0});return new Float32Array(r.getMappedRange()).set(e),r.unmap(),r},f.createGPUBufferUint=(t,e,i=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST)=>{const r=t.createBuffer({size:e.byteLength,usage:i,mappedAtCreation:!0});return new Uint32Array(r.getMappedRange()).set(e),r.unmap(),r};class l extends class{constructor(t,e=3,i,r,s,o){if(this.pos=n(0,0,0),this.scale=n(1,1,1),this.rotationAngles=n(0,0,0),this.vertex=i,this.vertexBuffer=f.createGPUBuffer(t,this.vertex),this.vertexPos=r,s){if(!o)throw new Error("Color buffer position not provided.");this.colors=s,this.colorBuffer=f.createGPUBuffer(t,this.colors),this.colorPos=o}this.model_matrix=a(),this.stride=e}get modelMatrix(){return this.createTransforms(),this.model_matrix}get numberOfVertex(){return this.vertex.length/this.stride}createTransforms(){h(this.model_matrix);const t=a(),e=a(),i=a(),r=a(),s=a();!function(t,e){t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1}(r,this.pos),function(t,e){var i=Math.sin(e),r=Math.cos(e);t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=r,t[6]=i,t[7]=0,t[8]=0,t[9]=-i,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1}(t,this.rotationAngles[0]),function(t,e){var i=Math.sin(e),r=Math.cos(e);t[0]=r,t[1]=0,t[2]=-i,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=i,t[9]=0,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1}(e,this.rotationAngles[1]),function(t,e){var i=Math.sin(e),r=Math.cos(e);t[0]=r,t[1]=i,t[2]=0,t[3]=0,t[4]=-i,t[5]=r,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1}(i,this.rotationAngles[2]),function(t,e){t[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1}(s,this.scale),c(this.model_matrix,t,s),c(this.model_matrix,e,this.model_matrix),c(this.model_matrix,i,this.model_matrix),c(this.model_matrix,r,this.model_matrix)}setBuffers(t){t.setVertexBuffer(this.vertexPos,this.vertexBuffer),this.colorBuffer&&t.setVertexBuffer(this.colorPos,this.colorBuffer)}}{constructor(t,e,i=3,r,s,n,o){super(t,i,r,s,n,o),this.indexes=e,this.indexBuffer=f.createGPUBufferUint(t,e),this.calculateNormals(),this.normalsBuffer=f.createGPUBuffer(t,this.normals)}get numberOfVertex(){return this.indexes.length}calculateNormals(){const t=new Array(this.vertex.length/this.stride*4).fill(0);for(let r=0;r<this.indexes.length;r+=3){const s=this.indexes[r],o=this.indexes[r+1],a=this.indexes[r+2],h=n(this.vertex[s*this.stride],this.vertex[s*this.stride+1],this.vertex[s*this.stride+2]),c=n(this.vertex[o*this.stride],this.vertex[o*this.stride+1],this.vertex[o*this.stride+2]),u=n(this.vertex[a*this.stride],this.vertex[a*this.stride+1],this.vertex[a*this.stride+2]),f=(e=n(c[0]-h[0],c[1]-h[1],c[2]-h[2]),i=n(u[0]-h[0],u[1]-h[1],u[2]-h[2]),n(e[1]*i[2]-e[2]*i[1],e[2]*i[0]-e[0]*i[2],e[0]*i[1]-e[1]*i[0]));t[4*s]+=f[0],t[4*s+1]+=f[1],t[4*s+2]+=f[2],t[4*o]+=f[0],t[4*o+1]+=f[1],t[4*o+2]+=f[2],t[4*a]+=f[0],t[4*a+1]+=f[1],t[4*a+2]+=f[2]}var e,i;this.normals=new Float32Array(t)}setBuffers(t){super.setBuffers(t),t.setIndexBuffer(this.indexBuffer,"uint32"),t.setVertexBuffer(1,this.normalsBuffer)}}class p{constructor(t,e,i){this.bindGroups=new Map,this.bindGroupEntries=new Map,this.layoutEntries=new Map,this.uniforms=[],this.bindGroupLayouts=new Map,this.using_mvp=!1,this.pipeline=e,i&&(this.mesh=i),this.device=t}appendUniformBuffer(t,e,...i){if(0===i.length)throw new Error("The data can't be undefined.");let r=0;for(const t of i)r+=t.length;r*=4;const s=this.device.createBuffer({size:r,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),n={binding:t,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{}};this.layoutEntries.get(e)||this.layoutEntries.set(e,new Map),this.layoutEntries.get(e).set(t,n);const o=this.device.createBindGroupLayout({entries:this.layoutEntries.get(e).values()}),a={binding:t,resource:{buffer:s,offset:0,size:r}};this.bindGroupEntries.get(e)||this.bindGroupEntries.set(e,new Map),this.bindGroupEntries.get(e).set(t,a);const h=this.device.createBindGroup({layout:o,entries:this.bindGroupEntries.get(e).values()});this.bindGroups.set(e,h),this.uniforms.push(new d(s,i)),this.bindGroupLayouts.set(e,o),this.pipeline.setLayout(this.device.createPipelineLayout({bindGroupLayouts:this.bindGroupLayouts.values()}))}setBindGroups(t){for(const e of this.bindGroups.keys())t.setBindGroup(Number(e),this.bindGroups.get(e))}writeUniforms(){for(const t of this.uniforms){let e=0;for(const i of t.information)this.device.queue.writeBuffer(t.buffer,e,i),e+=4*i.length}}getRenderPass(t,e,i){const r={colorAttachments:[{clearValue:[0,0,0,1],storeOp:"store",loadOp:"clear",view:e.getCurrentTexture().createView()}]};if(this.pipeline.depth){if(!i)throw new Error("Depth texture is needed.");const t={view:i.createView(),depthStoreOp:"store",depthClearValue:1,depthLoadOp:"clear"};r.depthStencilAttachment=t}return t.beginRenderPass(r)}draw(t,e,i,r){if(!this.mesh&&!r)throw new Error("unknown number of vertices.");if(this.using_mvp){const e=t.getViewProjection(),i=this.mesh?this.mesh.modelMatrix:a(),r=a();c(r,e,i),console.log(r,new Float32Array(r)),this.device.queue.writeBuffer(this.mvpUniformBuffer,0,r)}this.writeUniforms();const s=this.device.createCommandEncoder(),n=this.getRenderPass(s,e,i);n.setPipeline(this.pipeline.renderPipeline),this.mesh&&this.mesh.setBuffers(n),this.setBindGroups(n),this.mesh instanceof l?n.drawIndexed(this.mesh.numberOfVertex||r):n.draw(this.mesh.numberOfVertex||r),n.end(),this.device.queue.submit([s.finish()])}}class d{constructor(t,e){this.buffer=t,this.information=e}}var m=function(t,e,i,r){return new(i||(i=Promise))((function(s,n){function o(t){try{h(r.next(t))}catch(t){n(t)}}function a(t){try{h(r.throw(t))}catch(t){n(t)}}function h(t){var e;t.done?s(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(o,a)}h((r=r.apply(t,e||[])).next())}))};class v{init(){return m(this,void 0,void 0,(function*(){yield this.initGPU(),this.depthTexture=this.device.createTexture({format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT,size:[this.canvas.width,this.canvas.height,1]})}))}checkWebGPU(){return navigator.gpu?"webGPU suportado":"webGPU não suportado"}initGPU(){var t;return m(this,void 0,void 0,(function*(){const e=this.checkWebGPU();if("webGPU não suportado"===e)throw console.log(e),"Seu navegador atual não suporta webGPU!";this.canvas=document.querySelector("#canvas-webgpu");const i=window.devicePixelRatio||1;this.canvas.width=1024*i,this.canvas.height=768*i;const r=yield null===(t=navigator.gpu)||void 0===t?void 0:t.requestAdapter({powerPreference:"high-performance"});this.device=yield null==r?void 0:r.requestDevice(),this.context=this.canvas.getContext("webgpu"),this.context.configure({device:this.device,format:"bgra8unorm",alphaMode:"premultiplied"})}))}static build(){return m(this,void 0,void 0,(function*(){const t=new v;return yield t.init(),t}))}}v.build().then((t=>{const e=new o(1,[0,0,0]),i=new l(t.device,e.indexes,6,e.vertices,0);i.scale=[2,2,2];const r="\n        struct Light{\n            amb_c: vec4<f32>,\n            dif_c: vec4<f32>,\n            esp_c: vec4<f32>,\n            pos: vec4<f32>,\n            amb_k: f32,\n            dif_k: f32,\n            esp_k: f32,\n            esp_p: f32,\n        }\n\n        struct MVP{\n            model: mat4x4<f32>,\n            view: mat4x4<f32>,\n            proj: mat4x4<f32>,\n        }\n\n        @group(0) @binding(0)\n            var<uniform> matrices: MVP;\n\n            \n        @group(0) @binding(1) \n            var<uniform> light: Light;\n\n        struct Input{\n            @location(0) position: vec4<f32>,\n            @location(1) vColor: vec4<f32>,\n            @location(2) normal: vec4<f32>\n        }\n\n        struct Output{\n            @builtin(position) position: vec4<f32>,\n            @location(0) vColor: vec4<f32>,\n        }\n\n        @vertex\n        fn main(in: Input) -> Output {\n            var out: Output;\n\n            var lightPos = light.pos.xyz;\n            var pos = -(matrices.view * matrices.model * in.position).xyz;\n\n            var vNormal = normalize(matrices.view * matrices.model * in.normal).xyz;\n            var vDistance = normalize(pos - lightPos);\n\n            var normalPos = normalize(pos);\n\n            var halfVector= normalize(vDistance + normalPos);\n\n            var amb = light.amb_c * light.amb_k;\n\n            var diff = max(dot(vNormal, vDistance), 0.0) * light.dif_c * light.dif_k;\n\n            var spec = max(pow(dot(vNormal, halfVector), light.esp_p), 0.0)  * light.esp_c * light.esp_k;\n            \n            out.vColor = 0.7 * in.vColor + 0.3*(amb + diff + spec);\n            //out.vColor = in.vColor;\n            out.position = matrices.proj * matrices.view * matrices.model * in.position;\n\n            return out;\n        }\n    ",n="  \n        @fragment\n        fn main(@location(0) vColor: vec4<f32>) -> @location(0) vec4<f32> {\n            return vColor;\n        }\n    ",a=new f(t.device,r,n,"triangle-list"),h=new s([2,2,-1,1]),c=new u(t.canvas);c.camPosition=[0,0,4];const d=new p(t.device,a,i);d.appendUniformBuffer(0,0,new Float32Array(i.modelMatrix),new Float32Array(c.viewMatrix),new Float32Array(c.projMatrix)),h.createUniformBuffer(d,0,1),d.draw(c,t.context,t.depthTexture),document.addEventListener("keypress",(e=>{"p"!==e.key&&"o"!==e.key||(d.appendUniformBuffer(0,0,new Float32Array(i.modelMatrix),new Float32Array(c.viewMatrix),new Float32Array(c.projMatrix)),"p"==e.key?c.projectionType="perspective":c.projectionType="orthogonal",d.draw(c,t.context,t.depthTexture))}));let m=0;const v=()=>{h.newPos(m),h.createUniformBuffer(d,0,1),d.draw(c,t.context,t.depthTexture),m+=.01,requestAnimationFrame(v)};requestAnimationFrame(v)}))})();
//# sourceMappingURL=main.bundle.js.map