{"version":3,"file":"main.bundle.js","mappings":"6BAI8B,Y,MAC1B,MAAMA,ECJHC,UAAUC,IAAW,mBACjB,uBDKP,GAAc,yBAAXF,EAEC,MADAG,QAAQC,IAAIJ,GACP,0CAGT,MAAMK,EAASC,SAASC,cAAc,kBAEhCC,EAAmBC,OAAOD,kBAAoB,EACpDH,EAAOK,MAAQ,KAAOF,EACtBH,EAAOM,OAAS,IAAMH,EAEtB,MAAMI,QAA6B,QAAb,EAAAX,UAAUC,WAAG,eAAEW,iBAC/BC,QAAeF,aAAO,EAAPA,EAASG,gBACxBC,EAAUX,EAAOY,WAAW,UAE5BC,EAAgB,aAEtBF,EAAQG,UAAU,CACdL,SACAM,OAAOF,EACPG,UAAU,kBAQd,MAAMC,EElCO,wyBFkCPA,EERS,kJFSTC,EAAWT,EAAOU,qBAAqB,CACzCC,OAAO,CACHC,OAAOZ,EAAOa,mBAAmB,CAC7BC,KAAKN,IAETO,WAAW,QAEfC,SAAS,CACLJ,OAAOZ,EAAOa,mBAAmB,CAC7BC,KAAKN,IAETO,WAAW,OACXE,QAAQ,CAAC,CACLX,OAAOF,KAGfc,UAAU,CACNC,SAAS,iBAEbC,OAAO,SAGLC,EAAerB,EAAOsB,uBACtBC,EAAYrB,EAAQsB,oBAAoBC,aAExCC,EAAWL,EAAeM,gBAAgB,CAC5CC,iBAAiB,CAAC,CACdC,WAAW,CAAC,EAAK,EAAK,EAAK,GAC3BC,QAAQ,QACRC,OAAO,QACPC,KAAMT,MAGdG,EAAWO,YAAYxB,GACvBiB,EAAWQ,KAAK,EAAE,EAAE,EAAE,GACtBR,EAAWS,MAEXnC,EAAOoC,MAAMC,OAAO,CAAChB,EAAeiB,UACxC,E,YAtE8B,K,kPAAA,E","sources":["webpack://webgpu/./src/main.ts","webpack://webgpu/./src/helper.ts","webpack://webgpu/./src/shader.ts"],"sourcesContent":["import $ from \"jquery\";\r\nimport { checkWebGPU } from \"./helper\";\r\nimport { Shaders } from \"./shader\";\r\n\r\nconst createTriangle=async()=>{\r\n    const checkGpu=checkWebGPU();\r\n\r\n    if(checkGpu===\"webGPU não suportado\"){\r\n        console.log(checkGpu);\r\n        throw(\"Seu navegador atual não suporta webGPU!\");\r\n    }\r\n\r\n    const canvas = document.querySelector(\"#canvas-webgpu\") as HTMLCanvasElement;\r\n\r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n    canvas.width = 1024 * devicePixelRatio;\r\n    canvas.height = 768 * devicePixelRatio;\r\n\r\n    const adapter = await navigator.gpu?.requestAdapter() as GPUAdapter;\r\n    const device = await adapter?.requestDevice() as GPUDevice;\r\n    const context = canvas.getContext(\"webgpu\") as unknown as GPUCanvasContext;\r\n\r\n    const swapChainFormat='bgra8unorm';\r\n    //const swapChain=canvas.getContext('gpuswapchain')\r\n    context.configure({\r\n        device,\r\n        format:swapChainFormat,\r\n        alphaMode:\"premultiplied\"\r\n    })\r\n\r\n    /*context.configureSwapChain({\r\n        device:device,\r\n        format:swapChainFormat\r\n    })*/\r\n\r\n    const shaders=Shaders();\r\n    const pipeline = device.createRenderPipeline({\r\n        vertex:{\r\n            module:device.createShaderModule({\r\n                code:shaders.vertex\r\n            }),\r\n            entryPoint:\"main\",\r\n        },\r\n        fragment:{\r\n            module:device.createShaderModule({\r\n                code:shaders.fragment\r\n            }),\r\n            entryPoint:\"main\",\r\n            targets:[{\r\n                format:swapChainFormat\r\n            }]\r\n        },\r\n        primitive:{\r\n            topology:\"triangle-list\"\r\n        },\r\n        layout:'auto'\r\n    })\r\n\r\n    const commandEncoder=device.createCommandEncoder();\r\n    const textureView=context.getCurrentTexture().createView();\r\n\r\n    const renderPass=commandEncoder.beginRenderPass({\r\n        colorAttachments:[{\r\n            clearValue:[0.0, 0.0, 0.0, 1.0],\r\n            storeOp:\"store\",\r\n            loadOp:\"clear\",\r\n            view: textureView\r\n        }]\r\n    });\r\n    renderPass.setPipeline(pipeline);\r\n    renderPass.draw(3,1,0,0);\r\n    renderPass.end();\r\n\r\n    device.queue.submit([commandEncoder.finish()]);\r\n}\r\n\r\ncreateTriangle();\r\n","export const checkWebGPU=()=>{\r\n    if(navigator.gpu)return \"webGPU suportado\"\r\n    return \"webGPU não suportado\"\r\n}","export const Shaders=()=>{\r\n    const vertex=`\r\n        const pos: array<vec2<f32>, 3>=  array<vec2<f32>, 3>(\r\n            vec2<f32>(0.0, 0.5),\r\n            vec2<f32>(-0.5, -0.5),\r\n            vec2<f32>(0.5, -0.5),\r\n        );\r\n\r\n        const color: array<vec3<f32>, 3>=  array<vec3<f32>, 3>(\r\n            vec3<f32>(1.0, 0.0, 0.0),\r\n            vec3<f32>(0.0, 1.0, 0.0),\r\n            vec3<f32>(0.0, 0.0, 1.0)\r\n        );\r\n        \r\n        struct Output{\r\n            @builtin(position) Position: vec4<f32>,\r\n            @location(0) vColor: vec4<f32>,\r\n        }\r\n\r\n        @vertex\r\n        fn main(@builtin(vertex_index) VertexIndex: u32) -> Output {\r\n            var out: Output;\r\n            out.Position=vec4<f32>(pos[VertexIndex], 0.0, 1.0);\r\n            out.vColor=vec4<f32>(color[VertexIndex], 0.75);\r\n            return out;\r\n        }\r\n    `\r\n    const fragment=`  \r\n        @fragment\r\n        fn main(@location(0) vColor: vec4<f32>) -> @location(0) vec4<f32> {\r\n            return vColor;\r\n        }\r\n    `\r\n\r\n    return {vertex, fragment};\r\n}"],"names":["checkGpu","navigator","gpu","console","log","canvas","document","querySelector","devicePixelRatio","window","width","height","adapter","requestAdapter","device","requestDevice","context","getContext","swapChainFormat","configure","format","alphaMode","shaders","pipeline","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","fragment","targets","primitive","topology","layout","commandEncoder","createCommandEncoder","textureView","getCurrentTexture","createView","renderPass","beginRenderPass","colorAttachments","clearValue","storeOp","loadOp","view","setPipeline","draw","end","queue","submit","finish"],"sourceRoot":""}